{"componentChunkName":"component---src-templates-post-jsx","path":"/post/react-query","result":{"data":{"blogPost":{"latex":false,"parent":{"__typename":"MarkdownRemark","internal":{"content":"리액트에서 서버에서 데이터를 가져오고 관리하는 것은 너무너무 힘들다. 그래서 redux-thunk나 redux-saga같은 redux middleware를 많이 사용한다. 이에 여러가지 대안이 나왔지만 이 리스트에 단지 이름만 올리는 것 같지는 않은 라이브러리 **react-query**를 소개한다. 자매품으로 swr도 있으니 참고바란다.\n\n하지만 [문서](https://react-query.tanstack.com/)가 간단하게 잘 되어있으니 이 글 대신에 문서를 추천한다.\n\n## 기능\n\n- data fetching\n- caching-\n- syncing\n- +dev tools\n\n## Quick start\n\n```react\nasync function getTodos({ queryKey }): Promise<any> {\n  const [_, id] = queryKey;\n  return { id, title: \"post title\" }\n}\n\nfunction Todos() {\n   // Access the client\n   const queryClient = useQueryClient()\n\n   // Queries\n   const id = 1;\n   const todo = useQuery(['todo', id], getTodos);\n\n   // Mutations\n   const mutation = useMutation(postTodo, {\n     onSuccess: () => {\n       // Invalidate and refetch\n       queryClient.invalidateQueries(['todo', id])\n     },\n   })\n\n   return (\n     <div>\n       { todo.isLoading && <span>loading</span> }\n       { todo.isError && <span>error</span> }\n       { todo.data && <span>{todo.data.title}</span> }\n\n       <button\n         onClick={() => {\n           mutation.mutate({\n             id,\n             title: 'Do Laundry',\n           })\n         }}\n       >\n         Update Todo\n       </button>\n     </div>\n   )\n }\n\n // Create a client\n const queryClient = new QueryClient()\n\n function App() {\n   return (\n     // Provide the client to your App\n     <QueryClientProvider client={queryClient}>\n       <Todos />\n     </QueryClientProvider>\n   )\n }\n```\n\n## 장점\n\n- query key를 이용해 자동으로 캐시를 해준다.\n\n  - 여러 컴포넌트에서 같은 key를 사용해도 한번만 요청한다.\n\n- 윈도우가 포커스 되면 필요한 데이터들을 다시 받아온다.\n\n- 개발도구를 사용해 현재 react-query에서 관리하는 자원들을 볼 수 있다.\n\n## Query\n\n- 첫번째 파리마터로 queryKey를 받는다.\n\n- 두번째 파라미터로 promise를 반환하는 함수를 받는다. error를 throw. 함수는 parameter로 query key를 받는다.\n\n- ```typescript\n   function Todos({ status, page }) {\n     const result = useQuery(['todos', { status, page }], fetchTodoList)\n   }\n\n   // Access the key, status and page variables in your query function!\n   function fetchTodoList({ queryKey }) {\n     const [_key, { status, page }] = queryKey\n     return new Promise()\n   }\n  ```\n\n- 기본적으로 `useQuery`들을 사용하면 동시에 호출.\n\n- 여러 쿼리를 동적으로 사용할 때는 `useQueries`를 알아보자.\n\n- 다른 쿼리에 의존하는 쿼리를 사용한다면 `options.enabled` 사용하자.\n\n  - `options.enabled`가 `true`일때만 쿼리를 던진다.\n\n- `useIsFetching: () => boolean` hook은 어떤 쿼리가 fetching 중이면 true 반환하므로 전역적인 쿼리 상태를 알 수 있다.\n\n### Refetching\n\n- 기본적으로 윈도우가 focus될 때/되어 있을 때 마운팅 되어 있는 유효기간이 지난 쿼리를 다시 불러온다.\n  - refetchOnWindowFocus옵션으로 전역적/쿼리별 설정이 가능하다.\n  - 더 자세한 조작을 원하면 focusManager 사용하면 된다.\n\n## 추가기능\n\n- query cancellation\n- pagenated query\n- infinite query\n- prefetching\n- cache control\n- optimistic update\n- 그리고 여러가지 기능들...","description":null,"ignoreType":null,"mediaType":null},"html":"<p>리액트에서 서버에서 데이터를 가져오고 관리하는 것은 너무너무 힘들다. 그래서 redux-thunk나 redux-saga같은 redux middleware를 많이 사용한다. 이에 여러가지 대안이 나왔지만 이 리스트에 단지 이름만 올리는 것 같지는 않은 라이브러리 <strong>react-query</strong>를 소개한다. 자매품으로 swr도 있으니 참고바란다.</p>\n<p>하지만 <a href=\"https://react-query.tanstack.com/\">문서</a>가 간단하게 잘 되어있으니 이 글 대신에 문서를 추천한다.</p>\n<h2 id=\"기능\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%8A%A5\" aria-label=\"기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기능</h2>\n<ul>\n<li>data fetching</li>\n<li>caching-</li>\n<li>syncing</li>\n<li>+dev tools</li>\n</ul>\n<h2 id=\"quick-start\" style=\"position:relative;\"><a href=\"#quick-start\" aria-label=\"quick start permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Quick start</h2>\n<div class=\"gatsby-highlight\" data-language=\"react\"><pre class=\"language-react\"><code class=\"language-react\">async function getTodos({ queryKey }): Promise&lt;any&gt; {\n  const [_, id] = queryKey;\n  return { id, title: &quot;post title&quot; }\n}\n\nfunction Todos() {\n   // Access the client\n   const queryClient = useQueryClient()\n\n   // Queries\n   const id = 1;\n   const todo = useQuery([&#39;todo&#39;, id], getTodos);\n\n   // Mutations\n   const mutation = useMutation(postTodo, {\n     onSuccess: () =&gt; {\n       // Invalidate and refetch\n       queryClient.invalidateQueries([&#39;todo&#39;, id])\n     },\n   })\n\n   return (\n     &lt;div&gt;\n       { todo.isLoading &amp;&amp; &lt;span&gt;loading&lt;/span&gt; }\n       { todo.isError &amp;&amp; &lt;span&gt;error&lt;/span&gt; }\n       { todo.data &amp;&amp; &lt;span&gt;{todo.data.title}&lt;/span&gt; }\n\n       &lt;button\n         onClick={() =&gt; {\n           mutation.mutate({\n             id,\n             title: &#39;Do Laundry&#39;,\n           })\n         }}\n       &gt;\n         Update Todo\n       &lt;/button&gt;\n     &lt;/div&gt;\n   )\n }\n\n // Create a client\n const queryClient = new QueryClient()\n\n function App() {\n   return (\n     // Provide the client to your App\n     &lt;QueryClientProvider client={queryClient}&gt;\n       &lt;Todos /&gt;\n     &lt;/QueryClientProvider&gt;\n   )\n }</code></pre></div>\n<h2 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h2>\n<ul>\n<li>\n<p>query key를 이용해 자동으로 캐시를 해준다.</p>\n<ul>\n<li>여러 컴포넌트에서 같은 key를 사용해도 한번만 요청한다.</li>\n</ul>\n</li>\n<li>윈도우가 포커스 되면 필요한 데이터들을 다시 받아온다.</li>\n<li>개발도구를 사용해 현재 react-query에서 관리하는 자원들을 볼 수 있다.</li>\n</ul>\n<h2 id=\"query\" style=\"position:relative;\"><a href=\"#query\" aria-label=\"query permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Query</h2>\n<ul>\n<li>첫번째 파리마터로 queryKey를 받는다.</li>\n<li>두번째 파라미터로 promise를 반환하는 함수를 받는다. error를 throw. 함수는 parameter로 query key를 받는다.</li>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Todos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> status<span class=\"token punctuation\">,</span> page <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'todos'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> status<span class=\"token punctuation\">,</span> page <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> fetchTodoList<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Access the key, status and page variables in your query function!</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetchTodoList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> queryKey <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>_key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> status<span class=\"token punctuation\">,</span> page <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> queryKey\n <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token builtin\">Promise</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>기본적으로 <code class=\"language-text\">useQuery</code>들을 사용하면 동시에 호출.</li>\n<li>여러 쿼리를 동적으로 사용할 때는 <code class=\"language-text\">useQueries</code>를 알아보자.</li>\n<li>\n<p>다른 쿼리에 의존하는 쿼리를 사용한다면 <code class=\"language-text\">options.enabled</code> 사용하자.</p>\n<ul>\n<li><code class=\"language-text\">options.enabled</code>가 <code class=\"language-text\">true</code>일때만 쿼리를 던진다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">useIsFetching: () =&gt; boolean</code> hook은 어떤 쿼리가 fetching 중이면 true 반환하므로 전역적인 쿼리 상태를 알 수 있다.</li>\n</ul>\n<h3 id=\"refetching\" style=\"position:relative;\"><a href=\"#refetching\" aria-label=\"refetching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refetching</h3>\n<ul>\n<li>\n<p>기본적으로 윈도우가 focus될 때/되어 있을 때 마운팅 되어 있는 유효기간이 지난 쿼리를 다시 불러온다.</p>\n<ul>\n<li>refetchOnWindowFocus옵션으로 전역적/쿼리별 설정이 가능하다.</li>\n<li>더 자세한 조작을 원하면 focusManager 사용하면 된다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"추가기능\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EA%B8%B0%EB%8A%A5\" aria-label=\"추가기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가기능</h2>\n<ul>\n<li>query cancellation</li>\n<li>pagenated query</li>\n<li>infinite query</li>\n<li>prefetching</li>\n<li>cache control</li>\n<li>optimistic update</li>\n<li>그리고 여러가지 기능들...</li>\n</ul>"},"slug":"/react-query","tags":["react","react-query"],"title":"React query의 간단한 소개","excerpt":"","date":"2021-01-27T13:38:58.341Z"}},"pageContext":{"slug":"/react-query","nexttitle":"테스트 주도 개발에 대한 생각","nextslug":"/테스트-주도-개발에-대한-생각","prevtitle":"Big Test","prevslug":"/big-sample-test"}},"staticQueryHashes":[]}