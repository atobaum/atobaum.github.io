{"componentChunkName":"component---src-templates-post-jsx","path":"/post/http-완벽-가이드-정리","result":{"data":{"markdownRemark":{"html":"<h1 id=\"1장\" style=\"position:relative;\"><a href=\"#1%EC%9E%A5\" aria-label=\"1장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1장</h1>\n<p>HTTP는 단순한 문자열. 요청, 헤더, 본문으로 이루어짐.</p>\n<p>HTTP는 tcp로 전달됨(3은 udp쓴다던데...)\ntcp는</p>\n<ul>\n<li>오류 없는 데이터 전송</li>\n<li>순서에 맞는 전달</li>\n<li>조각 나지 않는 데이터 스트림\n을 제공한다.</li>\n</ul>\n<p>telnet으로 HTTP 요청을 해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ telnet www.google.com <span class=\"token number\">80</span>\nGET / HTTP/1.1\nHOST: www.google.com</code></pre></div>\n<p>웹 애플리케이션 중 특이한 사람들:</p>\n<ul>\n<li>프락시</li>\n<li>캐시</li>\n<li>게이트웨이</li>\n<li>터널</li>\n<li>에이전트\n자세한건 후술.</li>\n</ul>\n<h1 id=\"2장-url과-리소스\" style=\"position:relative;\"><a href=\"#2%EC%9E%A5-url%EA%B3%BC-%EB%A6%AC%EC%86%8C%EC%8A%A4\" aria-label=\"2장 url과 리소스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2장 URL과 리소스</h1>\n<p>헤더는 CRLF로 줄바꿈. body가 없어도 빈줄(CRLF)로 끝나야한다.</p>\n<h1 id=\"4장-커넥션-관리\" style=\"position:relative;\"><a href=\"#4%EC%9E%A5-%EC%BB%A4%EB%84%A5%EC%85%98-%EA%B4%80%EB%A6%AC\" aria-label=\"4장 커넥션 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4장 커넥션 관리</h1>\n<ul>\n<li>HTTP는 TCP/IP를 이용.</li>\n<li>\n<p>HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향르 받는다.</p>\n<h2 id=\"tcp-성능\" style=\"position:relative;\"><a href=\"#tcp-%EC%84%B1%EB%8A%A5\" aria-label=\"tcp 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 성능</h2>\n</li>\n<li>HTTP 트랜잭션을 처리하는 시간보다 TCP 연결 설정, 요청, 응답메시지 전송이 더 오래걸린다.</li>\n<li>TCP는 비싸다. 대부분의 HTTP 지연은 TCP 지연때문에 발생</li>\n<li>TCP 연결 핸드셰이크 지연</li>\n<li>확인 응답 지연: tcp 패킷의 확인 응답은 크기가 작아서 같은 곳으로 송출되는 패킷에 편승 시키는데 요청과 응답으로만 이루어지는 http 동작 방식은 기회를 감소시킨다.</li>\n<li>TCP slow start: tcp 연결이 만들어 진 후 시간이 지나면서 최대 속도제한이 늘어난다. 다른말로 초반에는 느리다.</li>\n<li>네이글 알고리즘: 크기가 작은 테이터는 한데 모아서 보낸다. </li>\n</ul>\n<h2 id=\"http-커넥션-관리\" style=\"position:relative;\"><a href=\"#http-%EC%BB%A4%EB%84%A5%EC%85%98-%EA%B4%80%EB%A6%AC\" aria-label=\"http 커넥션 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 커넥션 관리</h2>\n<p>어떻게 하면 HTTP 커넥션 성능을 향상시킬 수 있을 까?</p>\n<h3 id=\"parallel-connection\" style=\"position:relative;\"><a href=\"#parallel-connection\" aria-label=\"parallel connection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel connection</h3>\n<p>여러 커넥션으로 한꺼번에 처리. 그러나 대역폭이 충분하지 않으면 효과가 없고 오히려 관리비용때문에 느려질 수도 있다.\n브라우저는보총 적은 수(6-8개)의 커넥션을 사용한다.</p>\n<h3 id=\"persistent-connection\" style=\"position:relative;\"><a href=\"#persistent-connection\" aria-label=\"persistent connection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Persistent connection</h3>\n<p>한 페이지에 있는 링크들은 대부분 같은 서버에 있다. TCP 연결을 일회용으로 쓰지 않고 재사용. TCP 연결 지연 시간을 줄일 수 있다. 게다가 tcp의 느린 시작으로 인한 지연도 줄일 수 있다.</p>\n<p>keep-alive 헤더는 HTTP/1.1에서는 빠졌다. 그러나 아직 사용되고 있다. (HTTP/1.1에서는 지속 커넥션이 기본). 그러나 연결을 보장하지는 않는다. 누군가 언제든지 연결을 끊을 수 있음.</p>\n<p>중간에 프록시 서버가 있으면 문제가 생길 수 있다. 만약 프록시가 헤더를 살펴보지 않고 그냥 전달만 한다면 클라이언트와 서버는 각각 프록시와 연결이 지속될거라고 기대하는데 프록시는 양쪽과 연결을 끊어버린다. 이를 피하기 위해 중계 서버를 통해 이뤄질 경우 클라이언트는 Proxy-Connection 헤더를 사용하기도 한다. 만약 프록시가 멍청하다면 서버는 Connection 헤더가 없어서 연결을 끊고 프록시가 똑똑하면 Proxy-Connection을 Connection으로 바꿔보내고 연결을 유지한다. </p>\n<p>HTTP/1.1에서는 별도 설정을 하지 않는 한 모든 커넥션을 지속 커넥션으로 간주. HTTP/1.1 어플리케이션은 Connection: close를 명시해야한다.</p>\n<h3 id=\"pipelined-connection\" style=\"position:relative;\"><a href=\"#pipelined-connection\" aria-label=\"pipelined connection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pipelined connection</h3>\n<p>한 커넥션에서 응답이 도착하기 전에 요청을 보내기.</p>\n<ul>\n<li>지속 커넥션에서만 이용해야한다.</li>\n<li>HTTP 메시지는 순번이 정해져있지 않아 요청 순서과 똑같이 응답이 와야한다.</li>\n<li>HTTP 클라이언트는 커넥션이 언제 끊어지더라도 완료되지 않은 요청이 있으면 요청을 다시 보낼 준비가 되어있어야. 서버가 반만 보내고 연결 끊을 수도.</li>\n<li><strong>POST와 같이 반복해서 보낼 경우 문제가 생기는 요청은 보내면 안된다.</strong></li>\n</ul>\n<h2 id=\"어떻게-커넥션을-끊을까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BB%A4%EB%84%A5%EC%85%98%EC%9D%84-%EB%81%8A%EC%9D%84%EA%B9%8C\" aria-label=\"어떻게 커넥션을 끊을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 커넥션을 끊을까</h2>\n<ul>\n<li>마음대로 끊기\n주의: 몇번 실행됬는지에 상관 없이 결과가 같다면 멱등(idempotent)하다고 한다. GET, HEAD, PUT, DELETE 같은거. 그런데 POST 같이 멱등이 아닌 요청은 파이프라인을 통해 보내면 안된다.</li>\n<li>우아하게 끊기\n먼저 반만(출력체널)만 끊고 입력이 끊어지기를 기다릴 수도 있다.</li>\n</ul>\n<h1 id=\"7장-캐시\" style=\"position:relative;\"><a href=\"#7%EC%9E%A5-%EC%BA%90%EC%8B%9C\" aria-label=\"7장 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7장 캐시</h1>\n<p>캐시는 무엇을 해결할까:</p>\n<ul>\n<li>불필요한 데이터 전송</li>\n<li>대역폭 병목</li>\n<li>갑작스런 요청 쇄도</li>\n<li>거리로 인한 지연</li>\n</ul>\n<p>캐시는 무슨 문제가 있을까:</p>\n<ul>\n<li>캐시가 최신 정보인지 확인이 필요</li>\n</ul>\n<p>문제를 어떻게 해결할까:</p>\n<ul>\n<li>재검사(revalidation): 여러가지 방법이 있다. 예를들어 서버에 요청을 보내지만 If-Modified-Since 헤더를 이용. 안바뀌었으면 304 Not Modified 응답을 보낸다.</li>\n</ul>\n<h2 id=\"캐시-토폴로지\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80\" aria-label=\"캐시 토폴로지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시 토폴로지</h2>\n<ul>\n<li>개인 전용 캐시: 예를 들어 브라우저 내장 캐시</li>\n<li>공용 프락시 캐시</li>\n<li>프락시 캐시에도 계층이 있을 수 있다.</li>\n</ul>\n<h2 id=\"캐시-처리-단계\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EC%B2%98%EB%A6%AC-%EB%8B%A8%EA%B3%84\" aria-label=\"캐시 처리 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시 처리 단계</h2>\n<ol>\n<li>요청 받기</li>\n<li>파싱: 캐시가 요청에서 URL과 헤더들을 추출</li>\n<li>검색: 가지고 있는가?</li>\n<li>신선도 검사: 가지고 있으면 신선한지 (잘) 검사</li>\n<li>응답 생성</li>\n<li>발송</li>\n<li>로깅</li>\n</ol>\n<h2 id=\"신선한-사본\" style=\"position:relative;\"><a href=\"#%EC%8B%A0%EC%84%A0%ED%95%9C-%EC%82%AC%EB%B3%B8\" aria-label=\"신선한 사본 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>신선한 사본</h2>\n<p>HTTP는 Cache-Control과 Expires라는 헤더를 이용해 원 서버가 리소스에 유휴기간을 붙일 수 있도록 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Cache-Control: max-age=484200\nExpires: Fri, 05 Jul 2002, 05:00:00 GMT</code></pre></div>\n<p>Cache-Control: max-age는 남은 시간을 초로 지정. Expires는 유효기간은 GMT로 지정\n만약 캐시 서버의 시간이 동기화되있지 않으면 Expires는 잘 작동을 안 할 수도 있다.</p>\n<p>또는 ETag 사용: 주석 추가 같은 다르지만 같은 리소스나 최근 변경 일시를 정확하게 판별할 수 없거나 1초의 정밀도가 충분하지 않을 떄.</p>\n<h2 id=\"캐시제어\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EC%A0%9C%EC%96%B4\" aria-label=\"캐시제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시제어</h2>\n<ul>\n<li>Cache-Control: no-store: 리소스의 사본을 만드는 것을 금지. 개인정보가 들어있거나.</li>\n<li>Cache-Control: no-cache: 로컬 캐시 저장소에 저장될 수 있음. 다만 서버와 재검사 필수.</li>\n<li>Cache-Control: must-revalidate: 캐시는 성능 개선을 위해 만료된 객체를 제공할 수 있다. 이 헤더를 설정하면 ㅇ만료된 객체를 재검사 없이 재공해서는 안된다.</li>\n</ul>\n<h2 id=\"서버가-알려주지-않을-때\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84%EA%B0%80-%EC%95%8C%EB%A0%A4%EC%A3%BC%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C\" aria-label=\"서버가 알려주지 않을 때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버가 알려주지 않을 때</h2>\n<p>캐시 서버는 알아서 추측한다. 예를들어</p>\n<ul>\n<li>마지막 변경일이 오래됬다면 안정적인 문서로 예측, vice versa.</li>\n</ul>\n<h2 id=\"클라이언트-신손도-제약\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%8B%A0%EC%86%90%EB%8F%84-%EC%A0%9C%EC%95%BD\" aria-label=\"클라이언트 신손도 제약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클라이언트 신손도 제약</h2>\n<ul>\n<li>Cache-Control: max-stale: 신선하지 않아도 된다.</li>\n<li>Cache-Control: min-fresh = &#x3C;s>: 만료기간이 s초 이상 남아야 한다.</li>\n<li>등등</li>\n</ul>","timeToRead":5,"excerpt":"1장 HTTP는 단순한 문자열. 요청, 헤더, 본문으로 이루어짐. HTTP는 tcp로 전달됨(3은 udp쓴다던데...)\ntcp는 오류 없는 데이터 전송 순서에 맞는 전달 조각 나지 않는 데이터 스트림\n을 제공한다. telnet으로 HTTP…","frontmatter":{"title":"HTTP 완벽 가이드 정리","cover":null,"date":"2020-07-27T23:12:24+0900","category":null,"tags":["HTTP","Book","Summary"],"latex":false},"fields":{"slug":"/http-완벽-가이드-정리","date":"2020-07-27T00:00:00.000Z"}}},"pageContext":{"slug":"/http-완벽-가이드-정리","nexttitle":"Javascript에서 이벤트를 만들어보자.","nextslug":"/javascript에서-이벤트를-만들어보자","prevtitle":"객체지향의 사실과 오해","prevslug":"/객체지향의-사실과-오해"}},"staticQueryHashes":[]}