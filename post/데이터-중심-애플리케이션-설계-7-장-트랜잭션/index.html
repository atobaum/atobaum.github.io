<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.05020c8da71bf6a26c63.css" id="gatsby-global-css">.footer{margin-top:5rem;height:10rem;background-color:#000;color:#fff;bottom:0;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;padding:10px 5px 5px}.footer,.notice-container{display:-ms-flexbox;display:flex;align-items:center}.notice-container{width:13rem;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-pack:justify;justify-content:space-between;-ms-flex-line-pack:center;align-content:center;-ms-flex-align:center;margin-top:25px}@media (max-width:640px - 1px){.notice-container{-ms-flex-pack:distribute;justify-content:space-around}}.notice-container h4{text-align:center;margin:0}.GNB{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;padding:1.5rem}.GNB h2{margin:0}.progress-bar-container{position:fixed;top:0;width:100vw;height:5px;background-color:#bbb}.progress-bar-container>div{background-color:var(--theme-color);height:100%}*{-webkit-box-sizing:border-box;box-sizing:border-box}:root{--theme-color:#ffe400}.theme-color{color:var(--theme-color)}html{height:100%}body{margin:0;padding:0;min-height:100%;width:100%}.layout-container{min-height:100vh;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column}.layout__content-container{-ms-flex-positive:1;flex-grow:1;min-width:60%;max-width:960px;margin-left:auto;margin-right:auto}a{text-decoration:none;color:inherit}.tag{margin:1rem;color:#787878}.tag:before{content:"#"}.post-listing{list-style:none;padding:0}.post-preview{border-bottom:1px solid #787878;padding:1rem;display:block;margin-top:1rem}.post-preview header{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;margin-bottom:1rem}.post-preview:hover header{color:var(--theme-color)}.post-preview footer{margin-top:1.5rem;display:-ms-flexbox;display:flex}.post-preview footer>*{margin-right:1rem;color:#787878}.post-preview h2{margin:0}.posts-container{max-width:100vw}.listing-container{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center}.listing-container,.paging-container{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}.paging-container{min-width:15rem}code[class*=language-],pre[class*=language-]{font-family:Consolas,Menlo,Monaco,Andale Mono WT,Andale Mono,Lucida Console,Lucida Sans Typewriter,DejaVu Sans Mono,Bitstream Vera Sans Mono,Liberation Mono,Nimbus Mono L,Courier New,Courier,monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;background:#1d1f21;color:#c5c8c6}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{text-shadow:none;background:#b4b7b4}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:#b4b7b4}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#969896}.token.punctuation{color:#c5c8c6}.token.namespace{opacity:.7}.token.boolean,.token.number,.token.operator{color:#de935f}.token.property{color:#f0c674}.token.tag{color:#81a2be}.token.string{color:#8abeb7}.token.selector{color:#b294bb}.token.attr-name{color:#de935f}.language-css .token.string,.style .token.string,.token.entity,.token.url{color:#8abeb7}.token.attr-value,.token.control,.token.directive,.token.keyword,.token.unit{color:#b5bd68}.token.atrule,.token.regex,.token.statement{color:#8abeb7}.token.placeholder,.token.variable{color:#81a2be}.token.deleted{text-decoration:line-through}.token.inserted{border-bottom:1px dotted #fff;text-decoration:none}.token.italic{font-style:italic}.token.bold,.token.important{font-weight:700}.token.important{color:#c66}.token.entity{cursor:help}pre>code.highlight{outline:.4em solid #c66;outline-offset:.4em}.post-meta{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center}.post-container{padding:1rem}</style><meta name="generator" content="Gatsby 2.29.3"/><title data-react-helmet="true">데이터 중심 애플리케이션 설계 - 7장 트랜잭션 | atobaum</title><meta data-react-helmet="true" name="description" content="애매모호한 트랜잭션의 개념 트랙잭션은 ACID를 보장한다고 한다. ACID의 의미 Atomicity…"/><meta data-react-helmet="true" name="image" content="https://gatsby-advanced-starter-demo.netlify.com"/><meta data-react-helmet="true" property="og:url" content="https://gatsby-advanced-starter-demo.netlify.com/데이터-중심-애플리케이션-설계-7-장-트랜잭션"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="데이터 중심 애플리케이션 설계 - 7장 트랜잭션"/><meta data-react-helmet="true" property="og:description" content="애매모호한 트랜잭션의 개념 트랙잭션은 ACID를 보장한다고 한다. ACID의 의미 Atomicity…"/><meta data-react-helmet="true" property="og:image" content="https://gatsby-advanced-starter-demo.netlify.com"/><meta data-react-helmet="true" property="fb:app_id" content=""/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:creator" content=""/><meta data-react-helmet="true" name="twitter:title" content="데이터 중심 애플리케이션 설계 - 7장 트랜잭션"/><meta data-react-helmet="true" name="twitter:description" content="애매모호한 트랜잭션의 개념 트랙잭션은 ACID를 보장한다고 한다. ACID의 의미 Atomicity…"/><meta data-react-helmet="true" name="twitter:image" content="https://gatsby-advanced-starter-demo.netlify.com"/><script data-react-helmet="true" type="application/ld+json">[{"@context":"http://schema.org","@type":"WebSite","url":"https://gatsby-advanced-starter-demo.netlify.com","name":"데이터 중심 애플리케이션 설계 - 7장 트랜잭션","alternateName":"atobaum"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://gatsby-advanced-starter-demo.netlify.com/데이터-중심-애플리케이션-설계-7-장-트랜잭션","name":"데이터 중심 애플리케이션 설계 - 7장 트랜잭션","image":"https://gatsby-advanced-starter-demo.netlify.com"}}]},{"@context":"http://schema.org","@type":"BlogPosting","url":"https://gatsby-advanced-starter-demo.netlify.com","name":"데이터 중심 애플리케이션 설계 - 7장 트랜잭션","alternateName":"atobaum","headline":"데이터 중심 애플리케이션 설계 - 7장 트랜잭션","image":{"@type":"ImageObject","url":"https://gatsby-advanced-starter-demo.netlify.com"},"author":{"@type":"Person","name":"atobaum","email":"atobaum@gmail.com"},"publisher":{"@type":"Organization","name":"atobaum","email":"atobaum@gmail.com","logo":{"@type":"ImageObject","url":"https://gatsby-advanced-starter-demo.netlify.com/logos/logo-1024.png"}},"datePublished":"2020-09-21T00:00:00.000Z","description":"애매모호한 트랜잭션의 개념 트랙잭션은 ACID를 보장한다고 한다. ACID의 의미 Atomicity…"}]</script><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><meta name="theme-color" content="#FFE400"/><link rel="apple-touch-icon" sizes="192x192" href="/logos/logo-192.png"/><link rel="apple-touch-icon" sizes="512x512" href="/logos/logo-512.png"/><link rel="alternate" type="application/rss+xml" title="Gatsby Advanced Starter RSS feed" href="/rss.xml"/><link as="script" rel="preload" href="/webpack-runtime-ac968ca7b4d426fc8900.js"/><link as="script" rel="preload" href="/framework-55f7b2ba736e89fdc740.js"/><link as="script" rel="preload" href="/532a2f07-f2cdb2c94e5ef9f5c589.js"/><link as="script" rel="preload" href="/app-5a74487c9378356be313.js"/><link as="script" rel="preload" href="/styles-474c0340beb1ced255f1.js"/><link as="script" rel="preload" href="/cb1608f2-f11e37f427eb4c83525d.js"/><link as="script" rel="preload" href="/a9a7754c-57b45f76ce0a96963629.js"/><link as="script" rel="preload" href="/bb7f4ffa492396e127c4cdd5a08e6cd029ef69d4-d6203d4d98718660f286.js"/><link as="script" rel="preload" href="/055375637444d55e4c67d9f02f16300c0f7f7ba2-d3424c9ea53a87a3e7b3.js"/><link as="script" rel="preload" href="/e21e9ecfc099254b06ab7617f17d97212f9248d1-32bde8e5573ff9ef915e.js"/><link as="script" rel="preload" href="/component---src-templates-post-jsx-2b0cecb703aadd8b79e4.js"/><link as="fetch" rel="preload" href="/page-data/post/데이터-중심-애플리케이션-설계-7-장-트랜잭션/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="layout-container"><div class="progress-bar-container"><div style="width:0%"></div></div><header class="GNB"><a href="/"><h2>Atobaum</h2></a><nav><a href="/about">About</a></nav></header><div class="layout__content-container"><div class="post-container"><h1>데이터 중심 애플리케이션 설계 - 7장 트랜잭션</h1><div class="post-meta"><div class="post-tag-container"><a style="text-decoration:none" href="/tags/transaction"><span class="tag">Transaction</span></a><a style="text-decoration:none" href="/tags/study"><span class="tag">Study</span></a></div></div><div><h1 id="애매모호한-트랜잭션의-개념" style="position:relative;"><a href="#%EC%95%A0%EB%A7%A4%EB%AA%A8%ED%98%B8%ED%95%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B0%9C%EB%85%90" aria-label="애매모호한 트랜잭션의 개념 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>애매모호한 트랜잭션의 개념</h1>
<p>트랙잭션은 ACID를 보장한다고 한다.</p>
<h2 id="acid의-의미" style="position:relative;"><a href="#acid%EC%9D%98-%EC%9D%98%EB%AF%B8" aria-label="acid의 의미 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ACID의 의미</h2>
<h3 id="atomicity원자성" style="position:relative;"><a href="#atomicity%EC%9B%90%EC%9E%90%EC%84%B1" aria-label="atomicity원자성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Atomicity(원자성)</h3>
<p>동시성(여러 프로세스가 동시에 같은 데이터에 접근할 때)와 관련 없다. 동시성은 격리에서 다룬다.</p>
<p>시스템은 트랜잭션을 실행하기 전이나 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.</p>
<h3 id="consistenct일관성" style="position:relative;"><a href="#consistenct%EC%9D%BC%EA%B4%80%EC%84%B1" aria-label="consistenct일관성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consistenct(일관성)</h3>
<p>데이터에 관한 어떤 불변식이 항상 참을 뜻한다. 따라서 불변식에 의존하는데 불변식은 DB의 책임이 아니라 애플리케이션의 책임이다. (물론 유일성, 외래키 같이 DB의 책임인 것도 있다)</p>
<p>AID는 DB의 속싱이나 C는 DB의 속성이 아니다.</p>
<h3 id="isolation격리성" style="position:relative;"><a href="#isolation%EA%B2%A9%EB%A6%AC%EC%84%B1" aria-label="isolation격리성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Isolation(격리성)</h3>
<p>동시성의 문제. 트랜잭션끼리 서로 격리되어 있고 다른 트랜잭션을 방해할 수 없다. 따라서 다른 트랜잭션을 신경 쓸 필요 없게 해준다.</p>
<p>여러 트랜잭션이 동시에 실행되었을 때 DB는 이들이 순차적으로 실행됐을 때와 동일한 결과를 내도록 보장한다.</p>
<p>그러나 완전한 직렬성 격리는 성능 손실이 있으므로 대부분의 상황에서는 완화된 수준의 격리성을 사용한다.</p>
<h3 id="durability지속성" style="position:relative;"><a href="#durability%EC%A7%80%EC%86%8D%EC%84%B1" aria-label="durability지속성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Durability(지속성)</h3>
<p>트랜잭션 후 커밋한 데이터는 손실되지 않는다.</p>
<ul>
<li>단일 노드 DB에서는 일반적으로 데이터가 HDD/SDD같은 비휘발성 저장 매체에 기록됐다는 뜻.</li>
<li>복제 기능이 있는 DB에서는 보통 여러 노드에 복사되었다는 뜻.</li>
</ul>
<h2 id="단일-객체-연산과-다중-객체-연산" style="position:relative;"><a href="#%EB%8B%A8%EC%9D%BC-%EA%B0%9D%EC%B2%B4-%EC%97%B0%EC%82%B0%EA%B3%BC-%EB%8B%A4%EC%A4%91-%EA%B0%9D%EC%B2%B4-%EC%97%B0%EC%82%B0" aria-label="단일 객체 연산과 다중 객체 연산 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>단일 객체 연산과 다중 객체 연산</h2>
<p>단일 객체를 변경할 때도 원자성과 격리성은 적용된다. 예를 들어 20KB JSON 문서를 저장할 때</p>
<ul>
<li>첫 10KB를 보낸 후 네트워크 연결이 끊기면 DB는 받은 JSON 조각을 저장할 것인가</li>
<li>DB가 디스크에 저장된 기존 값을 덮어 쓸 때 전원이 나가면 어떻게 될까</li>
<li>문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽으면 어떤 값을 줄까</li>
</ul>
<h1 id="완화된-격리수준" style="position:relative;"><a href="#%EC%99%84%ED%99%94%EB%90%9C-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80" aria-label="완화된 격리수준 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>완화된 격리수준</h1>
<p>동시성 문제는 언제나 어려운 문제. DB는 트랜잭션 격리를 제공해 동시성 문제를 감추었다. <strong>직렬성 격리</strong>는 여러 트랜잭션이 직렬적으로 실행되는 것과 등일한 결과가 나오는 것을 보장. 그런데 직렬성 격리는 성능 손실이 있다. 따라서 DB는 어떤 동시성 문제는 보호해주지 않는 격리수준을 제공한다.</p>
<h2 id="커밋-후-읽기read-committed" style="position:relative;"><a href="#%EC%BB%A4%EB%B0%8B-%ED%9B%84-%EC%9D%BD%EA%B8%B0read-committed" aria-label="커밋 후 읽기read committed permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>커밋 후 읽기(read committed)</h2>
<p>다음 두가지를 보장</p>
<ul>
<li>더티 읽기가 없다: DB에서 읽을 때 커밋된 데이터만 보게된다.</li>
<li>더티 쓰기가 없다: DB에 쓸 때 커밋된 데이터만 덮어쓰게 된다.</li>
</ul>
<h3 id="더티-읽기dirty-read" style="position:relative;"><a href="#%EB%8D%94%ED%8B%B0-%EC%9D%BD%EA%B8%B0dirty-read" aria-label="더티 읽기dirty read permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>더티 읽기(dirty read)</h3>
<p>트랜젝션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 보는 것을 더티 읽기라고 한다.</p>
<p>막는 이유</p>
<ol>
<li>트랜잭션이 여러 객체를 갱신할 때 더티 읽기가 생기면 다른 트랜잭션이 일관적이지 않은 데이터를 볼 수 있다.</li>
<li>트랙잭션이 롤백될 때 더티 읽기가 생기면 나중에 롤백될, 즉 DB에 쓰이지 않을 데이터가 보일 수 있다.</li>
</ol>
<h3 id="더티-쓰기dirty-write" style="position:relative;"><a href="#%EB%8D%94%ED%8B%B0-%EC%93%B0%EA%B8%B0dirty-write" aria-label="더티 쓰기dirty write permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>더티 쓰기(dirty write)</h3>
<p>두 트랜잭션이 동일한 객체를 갱신하려고 할 때 나중에 실행된 갱신이 커밋되지 않은 값을 덮어 쓰는 것을 더티 쓰기라고 한다.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/0c45200938bb46e961971bc829507623/862f9/fig7-5.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 53.75722543352601%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe6npQH/xAAXEAEBAQEAAAAAAAAAAAAAAAABABAR/9oACAEBAAEFAtHpF//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABgQAQEBAQEAAAAAAAAAAAAAAAEAIRGB/9oACAEBAAE/IXfJ4xNq3bRf/9oADAMBAAIAAwAAABCjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAQEBAQAAAAAAAAAAAAERACExQWH/2gAIAQEAAT8QPVZ6NyC1P3VO4Y2vuFR+zNqt3//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Fig.7-5"
        title="Fig.7-5"
        src="/static/0c45200938bb46e961971bc829507623/15ec7/fig7-5.jpg"
        srcset="/static/0c45200938bb46e961971bc829507623/9ac50/fig7-5.jpg 173w,
/static/0c45200938bb46e961971bc829507623/8d48c/fig7-5.jpg 345w,
/static/0c45200938bb46e961971bc829507623/15ec7/fig7-5.jpg 690w,
/static/0c45200938bb46e961971bc829507623/af659/fig7-5.jpg 1035w,
/static/0c45200938bb46e961971bc829507623/89b2d/fig7-5.jpg 1380w,
/static/0c45200938bb46e961971bc829507623/862f9/fig7-5.jpg 1656w"
        sizes="(max-width: 690px) 100vw, 690px"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
        loading="lazy"
      />
  </a>
    </span></p>
<p>위 그림에서 구매자는 밥이 되었고 송장은 앨리스에게 전송되 데이터의 일관성이 어긋난다.</p>
<h3 id="구현" style="position:relative;"><a href="#%EA%B5%AC%ED%98%84" aria-label="구현 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>구현</h3>
<p>커밋 후 읽기는 많은 DB의 기본 설정.</p>
<h4 id="더티-쓰기-막기" style="position:relative;"><a href="#%EB%8D%94%ED%8B%B0-%EC%93%B0%EA%B8%B0-%EB%A7%89%EA%B8%B0" aria-label="더티 쓰기 막기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>더티 쓰기 막기</h4>
<p>보통 row 수준 잠금을 통해. 트랜잭션이 특정 객체(row/문서)를 쓰기 위해서는 해당 객체에 대한 잠금을 획득해야 한다. 하나의 트랜잭션만 row에 대한 소유권을 가지고 있다가 커밋 시 소유권을 내놓는다. 따라서 두번째 트랜잭션이 갱신을 하려면 첫번째 트랜잭션이 commit/abort를 해야한다.</p>
<h4 id="더티-읽기-막기" style="position:relative;"><a href="#%EB%8D%94%ED%8B%B0-%EC%9D%BD%EA%B8%B0-%EB%A7%89%EA%B8%B0" aria-label="더티 읽기 막기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>더티 읽기 막기</h4>
<p>위와 같은 잠금을 사용해 읽기도 막으면 가능하다. 읽기 전에 잠금을 획득하고 읽은 후에 바로 잠금을 해제하는 것이다. 이렇게 하면 갱신되었으나 아직 커밋되지 않은 데이터는 아무도 읽을 수 없게 된다.</p>
<p>그러나 이 방법은 성능이 안좋다. 읽기만 하는 여러 트랜잭션이 오랫동안 실행되는 하나의 쓰기 트랜잭션을 기다려야 할 수도 있기 때문이다. 따라서 대부분의 DB는 갱신된 객체에 대해 과거의 값과 아직 커밋되지 않은 트랜잭션에서 갱신한 값을 모두 가지고 있다가 그 트랜잭션이 커밋하기 전에는 과거의 값을 돌려준다.</p>
<h3 id="문제" style="position:relative;"><a href="#%EB%AC%B8%EC%A0%9C" aria-label="문제 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>문제</h3>
<p>커밋 후 읽기 격리를 사용해도 동시성 버그가 생길 수 있다.</p>
<!-- ![Fig.7-6](/images/DDIA/fig7-6.jpg) -->
<p>위 상황에서 앨리스에게 잔고 100이 사라진 것처럼 보인다. 이런 현상을 <strong>비반복 읽기(nonrepeatable read)</strong> 또는 <strong>읽기 스큐(read skew)</strong>라고 한다. 읽기 스큐는 지속적인 문제는 아니다. 그러나 이런 일시적인 비일관성을 감내할 수 없는 경우도 있다.</p>
<ul>
<li>백업: 백업은 몇시간까지 걸릴 수 있다. 백업이 실행 중일때도 DB는 계속 업데이트된다. 이 경우 이 백업을 사용해서 복원을 하면 비일관성이 계속 있을 수 있다.</li>
<li>분석 질의/무결성 확인: DB의 큰 부분을 질의할 때 또는 주기적인 무결성 확인 시 잘못된 결과를 반환할 수 있다.</li>
</ul>
<p>스냅숏 격리는 이런 문제의 가장 흔한 해결책이다.</p>
<h2 id="스냅숏-격리와-반복-읽기" style="position:relative;"><a href="#%EC%8A%A4%EB%83%85%EC%88%8F-%EA%B2%A9%EB%A6%AC%EC%99%80-%EB%B0%98%EB%B3%B5-%EC%9D%BD%EA%B8%B0" aria-label="스냅숏 격리와 반복 읽기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>스냅숏 격리와 반복 읽기</h2>
<p>각 트랜잭션은 DB의 일관된 스냅숏으로부터 읽는다. 스냅숏 격리는 읽기와 쓰기가 서로 차단하지 않는다.</p>
<h3 id="구현-1" style="position:relative;"><a href="#%EA%B5%AC%ED%98%84-1" aria-label="구현 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>구현</h3>
<p>더티 쓰기 방지를 위해 커밋 후 읽기처럼 쓰기 잠금을 사용한다. 그러나 더티 읽기 방지를 위해 잠금을 사용할 필요가 없다.</p>
<p>DB는 진행중인 트랜잭션이 서로 다른 시점의 DB를 볼 수 있게 해야한다. DB가 동시에 여러 버전의 객체를 유지하는 방법을 <strong>다중 버전 동시성 제어(multi-version concurrency control, MVCC)</strong>라고 한다.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 661px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/b4c800e242954af30f21ff358393318e/af07a/fig7-7.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 79.76878612716763%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdwguD//xAAXEAADAQAAAAAAAAAAAAAAAAAAASEQ/9oACAEBAAEFAmK5B3P/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAADAQADAAAAAAAAAAAAAAABESEAEEFh/9oACAEBAAE/IWiuKgQkeC1jHugQ1ut//9oADAMBAAIAAwAAABCjz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAAIDAQEAAAAAAAAAAAAAAAERACExQXH/2gAIAQEAAT8QB0I2S8luAR7AKu5ULoC1FWmGsQBAG0Nn/9k='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Fig.7-7"
        title="Fig.7-7"
        src="/static/b4c800e242954af30f21ff358393318e/af07a/fig7-7.jpg"
        srcset="/static/b4c800e242954af30f21ff358393318e/9ac50/fig7-7.jpg 173w,
/static/b4c800e242954af30f21ff358393318e/8d48c/fig7-7.jpg 345w,
/static/b4c800e242954af30f21ff358393318e/af07a/fig7-7.jpg 661w"
        sizes="(max-width: 661px) 100vw, 661px"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
        loading="lazy"
      />
  </a>
    </span></p>
<ul>
<li>Postgresql에서 MVCC를 구현하는 방법</li>
</ul>
<p>각 트랜잭션은 계속 증가하는 트랜잭션 id를 할당 받는다. 트랜잭션이 객체를 갱신하면 이전 객체의 deleted by에 해당 트랜잭션 id를 저장하고 새 객체를 만든다. 그리고 DB는 다음 목록에 해당하는 객체는 숨긴다.</p>
<ol>
<li>DB는 트랜잭션이 시작할 때 그 시점에 진행중인 모든 트랜잭션 목록을 만들고 이 트랜잭션들이 쓴 데이터는 무시한다.</li>
<li>abort된 트랜잭션도 무시한다.</li>
<li>트랜잭션 id가 더 큰 트랜잭션이 쓴 데이터도 무시한다.</li>
</ol>
<p>즉 트랜잭션은</p>
<ol>
<li>시작할 때 커밋된 트랜잭션이 쓴 데이터</li>
<li>deleted by == null 또는 트랜잭션 시작 시 deleted by를 한 트랜잭션이 커밋되지 않은 데이터
를 볼 수 있다.</li>
</ol>
<h2 id="갱신-손실-방지" style="position:relative;"><a href="#%EA%B0%B1%EC%8B%A0-%EC%86%90%EC%8B%A4-%EB%B0%A9%EC%A7%80" aria-label="갱신 손실 방지 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>갱신 손실 방지</h2>
<p>앞의 두 격리 수준은 동시에 실행되는 쓰기가 있을 때 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 문제에 대한 것이었다. 두 트랜잭션이 동시에 쓰기를 할 때 생기는 문제는 더티 쓰기만 다루었다.
두 트랜잭션이 동시에 쓸 때 발생하는 문제는 <strong>갱신 손실(lost update)</strong>도 있다. 두 트랜잭션이 값을 읽고 갱신 할 때 (read-modify-write 주기)에서 동기화 문제가 생길 수 있다. 예를들어</p>
<ol>
<li>두 트랜잭션이 같은 값을 읽고 (x=1), x = x+1=2로 update한다.</li>
<li>JSON 배열에 객체를 추가한다.
이 경우 첫번째 쓰기는 두번째 쓰기에 의해 무시된다.</li>
</ol>
<h3 id="해결책" style="position:relative;"><a href="#%ED%95%B4%EA%B2%B0%EC%B1%85" aria-label="해결책 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>해결책</h3>
<h4 id="원자적-쓰기-연산" style="position:relative;"><a href="#%EC%9B%90%EC%9E%90%EC%A0%81-%EC%93%B0%EA%B8%B0-%EC%97%B0%EC%82%B0" aria-label="원자적 쓰기 연산 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>원자적 쓰기 연산</h4>
<p>애플리케이션에서 read-modify-write 주기를 구현할 필요 없이 DB가 제공하는 원자적 갱신 연산을 사용한다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> counter <span class="token keyword">SET</span> x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></div>
<p>몽고DB 같은 문서 DB도 JSON 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공한다.</p>
<p>그러나 모든 쓰기가 쉽게 원자적 연산으로 표현할 수는 없다.</p>
<h4 id="명시적인-잠금" style="position:relative;"><a href="#%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9D%B8-%EC%9E%A0%EA%B8%88" aria-label="명시적인 잠금 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>명시적인 잠금</h4>
<p>애플리케이션이 갱신할 객체를 명시적으로 잠그고 다른 애플리케이션은 잠금이 해제될 때 까지 기다리면 된다. 그러나 어디선가 잠금을 해제하는 것을 잊어버려 경쟁조건을 유발하기가 쉽다.</p>
<h3 id="경쟁-손실-자동-감지" style="position:relative;"><a href="#%EA%B2%BD%EC%9F%81-%EC%86%90%EC%8B%A4-%EC%9E%90%EB%8F%99-%EA%B0%90%EC%A7%80" aria-label="경쟁 손실 자동 감지 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>경쟁 손실 자동 감지</h3>
<p>또는 그냥 병렬 실행을 허용하고 DB가 충돌을 감지해 트랜잭션을 abort 시키는 방법도 있다. 이 방법의 이점은스냅숏 격리와 결합해 효율적으로 수행할 수 있다는 장점이 있다.</p>
<h3 id="compare-and-set" style="position:relative;"><a href="#compare-and-set" aria-label="compare and set permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compare-and-set</h3>
<p>트랜잭션을 제공하지 않는 DB중에 원자적 compare-and-set연산을 제공하는 것도 있다. 이 연산은 마지막으로 읽은 후 변경되지 않았을 때만 갱신을 허용해 갱신손실을 피한다. 예를들면</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> page <span class="token keyword">SET</span> content<span class="token operator">=</span><span class="token string">"new"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">AND</span> content<span class="token operator">=</span><span class="token string">"old"</span><span class="token punctuation">;</span></code></pre></div>
<p>그러나 DB가 where절이 오래된 스냅숏으로 부터 읽는 것을 허용하면 잘 작동하지 않는다.</p>
<h3 id="복제된-db" style="position:relative;"><a href="#%EB%B3%B5%EC%A0%9C%EB%90%9C-db" aria-label="복제된 db permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>복제된 DB</h3>
<p>복제된 DB에서 갱신손실을 막는 것은 다른 차원의 문제이다. 복제된 DB는 보통 여러 쓰기가 동시에 실행되고 비동기적으로 복제가 되므로 잠금과 compare-and-set을 이용할 수 없다. 대신 충돌된 버전을 허용하고 나중에 충돌을 해소하는 방법을 많이 사용한다.</p>
<p>원자적 연산은 복제 상황에서도 잘 작동한다. 특히 commutative한 연산은.</p>
<h2 id="쓰기-스큐와-팬텀" style="position:relative;"><a href="#%EC%93%B0%EA%B8%B0-%EC%8A%A4%ED%81%90%EC%99%80-%ED%8C%AC%ED%85%80" aria-label="쓰기 스큐와 팬텀 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>쓰기 스큐와 팬텀</h2>
<p>동시 쓰기가 유발하는 문제는 또 있다. <code class="language-text">on_call=true</code>인 사람이 최소 한명 이상 있어야 한다고 해 보자.
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 661px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/860e396d05352be66624e778bc28bd1d/af07a/fig7-8.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 75.14450867052024%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe5UNA//xAAYEAACAwAAAAAAAAAAAAAAAAAAECExQf/aAAgBAQABBQLVBa//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAACAgMBAAAAAAAAAAAAAAAAAREhEDFRcf/aAAgBAQABPyFbWNOKZ6Jjicf/2gAMAwEAAgADAAAAEMDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAQACAgMAAAAAAAAAAAAAAREAITFBYXGB/9oACAEBAAE/EG8CXjOwG0wEDS+sC2lfGXZKrqawIBv7n//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Fig.7-8"
        title="Fig.7-8"
        src="/static/860e396d05352be66624e778bc28bd1d/af07a/fig7-8.jpg"
        srcset="/static/860e396d05352be66624e778bc28bd1d/9ac50/fig7-8.jpg 173w,
/static/860e396d05352be66624e778bc28bd1d/8d48c/fig7-8.jpg 345w,
/static/860e396d05352be66624e778bc28bd1d/af07a/fig7-8.jpg 661w"
        sizes="(max-width: 661px) 100vw, 661px"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
        loading="lazy"
      />
  </a>
    </span></p>
<p>위와 같은 현상을 쓰기 스큐(write skew)라고 한다. 두 트랜잭션이 다른 객체를 갱신하므로 더티 쓰기도 갱신 손실도 아니다.</p>
<ul>
<li>여러 객체가 관련되므로 원자적 계산은 도움이 안된다.</li>
<li>일부 스냅숏 격리 구현에서 제공되는 갱신손실감지도 도움되지 않는다.</li>
<li>직렬성 격리를 사용할 수 없다면 의존하는 row를 명시적으로 잠그는 것이 차선이다. (for update)</li>
</ul>
<h3 id="다른-예" style="position:relative;"><a href="#%EB%8B%A4%EB%A5%B8-%EC%98%88" aria-label="다른 예 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>다른 예</h3>
<ul>
<li>회의실 예약. 해당하는 시간에 예약이 없는지 확인한 후 예약 row를 insert한다.</li>
<li>사용자명. 해당 사용자가 없는 것을 확인한 후 사용자를 insert한다.</li>
</ul>
<p>쓰기 스큐는 비슷한 패턴을 가진다.</p>
<ol>
<li>어떤 검색 조건에 부합하는 row를 선택 수 요구사항을 확인한다.</li>
<li>그 결과에 따라 애플리케이션은 처리를 분기한다.</li>
<li>업데이트하기로 결정 했으면 DB에 쓴다. 이 결과로 2를 결정하는 조건이 바뀐다.
이처럼 트랜잭션에서 쓴 결과가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 <strong>팬텀(phantom)</strong>이라고 한다.</li>
</ol>
<p>의사 호출 예제에서는 잠글 수 있는 row가 있었지만 다른 예에서는 잠글 수 있는 row가 없다.</p>
<h3 id="해결법" style="position:relative;"><a href="#%ED%95%B4%EA%B2%B0%EB%B2%95" aria-label="해결법 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>해결법</h3>
<p>회의실 예약 예제에서 시해당 시간에 해당하는 row들을 미리 만들어 놓으면 해결할 수 있다. 이와 같이 팬텀을 DB에 존재하는 구체적인 row에 대한 잠금충돌로 바꾸는 방법을 충돌 구체화(materializing conflit)라고 한다. 그러나 이 방법은 알아내기 어렵고 오류가 발생하기도 쉽다. 그렇기 때문에 대부분의 경우 직렬성 격리 수준이 더 선호된다.</p>
<h1 id="직렬성" style="position:relative;"><a href="#%EC%A7%81%EB%A0%AC%EC%84%B1" aria-label="직렬성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>직렬성</h1>
<p>직렬성 격리수준은 여러 트랜잭션이 병렬로 실행되도 직렬로 실행된 것과 동일한 결과를 보장한다. 따라서 모든 경쟁조건을 막을 수 있다.</p>
<p>오늘날 대부분의 DB는 직렬성을</p>
<ul>
<li>진짜로 순차적으로 실행</li>
<li>2단계 잠금</li>
<li>직렬성 스냅숏 격리
를 통해 구현한다.</li>
</ul>
<h2 id="실제적인-직렬-실행" style="position:relative;"><a href="#%EC%8B%A4%EC%A0%9C%EC%A0%81%EC%9D%B8-%EC%A7%81%EB%A0%AC-%EC%8B%A4%ED%96%89" aria-label="실제적인 직렬 실행 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>실제적인 직렬 실행</h2>
<p>한번에 트랜잭션 하나씩 단일 스래드에서 진행하면 된다.</p>
<ul>
<li>트랜잭션 시간이 아주 짧고</li>
<li>모든 활성화된 데이터가 메모리에 있고(오랫동안 사용하지 않는 데이터는 디스크에 있어도 ok)</li>
<li>단일 CPU에서 실행할 정도로 처리량이 낮을 때
는 괜찮은 선택이다.</li>
</ul>
<p>처리량이 CPU 코어 하나에 제한되기 때문에 단일 스래드를 최대한 활용하려면 트랜잭션이 다르게 구조화되어야 한다.</p>
<h3 id="stored-procedure" style="position:relative;"><a href="#stored-procedure" aria-label="stored procedure permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stored procedure</h3>
<p>보통 애플리케이션이 구문을 하나씩 실행한다. 그런데 이 경우 애플리케이션과 DB 사이의 네트워크 통신이 너무 길다. 따라서 하나의 트랜잭션을 한꺼번에 DB에 제출하면 네트워크 비용을 줄일 수 있다.</p>
<ul>
<li>DB마다 스토어드 프로시저용 언어가 다를 수 있다. 또 이 언어들은 오늘날 범용 언어의 발전을 따라잡지 못해 대부분 조잡하다. 그러나 현대의 스토어드 프로시저 구현은 lua, java 같은 범용 언어를 사용하기 때문에 해결할 수 있다.</li>
<li>DB에서 실행되는 코드는 디버깅도 어렵고 버전 관리 및 배포가 불편하는 등 관리가 어렵다.</li>
<li>보통 여러 애플리케이션이 하나의 DB를 공유하기 때문에 잘못 작성된 오랜 시간이 걸리는 스토어드 프로시저는 유쾌하지 않은 상황을 유발한다.</li>
</ul>
<p>스토어드 프로시저가 있고 데이터가 메모리에 저장된다면 모든 트랜잭션을 하나의 스래드에서 실행하는게 현실성있다.</p>
<p>여러 파티션에 결친 트랜잭션도 쓸 수 있지만 제한이 있다.</p>
<h2 id="2단계-잠금2pl" style="position:relative;"><a href="#2%EB%8B%A8%EA%B3%84-%EC%9E%A0%EA%B8%882pl" aria-label="2단계 잠금2pl permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2단계 잠금(2PL)</h2>
<p>약 30년동안 직렬성을 구현하는데 널리 쓰인 알고리즘. 2단계 잠금(two-phase locking, 2PL).</p>
<ul>
<li>잠금에 두가지 모드가 있다: 공유모드, 독점 모드.</li>
<li>트랜잭션은 읽을 때 공유 모드 잠금을 얻어야 한다.</li>
<li>트랜잭션은 갱신할 때 독점 모드 잠금을 얻어야 한다.</li>
<li>독점 모드 잠금은 모든 공유 모드 잠금을 가지고 있는 트랜잭션이 없을 때 혼자만 가질 수 있다.</li>
<li>2PL은 스냅숏 격리와 다르게 읽기와 쓰기가 서로 막는다.</li>
<li>
<p>2PL은 dead lock이 발생하기 쉽다.</p>
<ul>
<li>두 트랜잭션이 같은 row를 읽은 후 쓰려고 할 때.</li>
<li>이때 DB는 교착상태를 감지하고 하나를 abort 시킨다.</li>
</ul>
</li>
</ul>
<h3 id="성능" style="position:relative;"><a href="#%EC%84%B1%EB%8A%A5" aria-label="성능 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>성능</h3>
<ul>
<li>2PL의 가장 큰 단점은 성능.</li>
<li>동시성이 줄어들기 때문에 완화된 격리수준보다 응답시간이 크게 저하된다.</li>
<li>잠금 기반 커밋 후 읽기 격리보다 교착생태가 훨씬 더 자주 발생한다.</li>
<li>많은 데이터를 읽는 트랜잭션이 있으면 성능이 크게 저하된다.</li>
</ul>
<h3 id="서술-잠금predicate-lock" style="position:relative;"><a href="#%EC%84%9C%EC%88%A0-%EC%9E%A0%EA%B8%88predicate-lock" aria-label="서술 잠금predicate lock permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>서술 잠금(Predicate lock)</h3>
<p>직렬성 격리는 팬텀을 막아야 한다. 개념상 서술잠금이 필요하다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> page <span class="token keyword">WHERE</span> id <span class="token operator">></span> <span class="token number">5</span> <span class="token operator">AND</span> id <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre></div>
<p>서술 잠금은 특정 객체가 아니라 어떤 검색 조건에 부합하는 객체를 잠구어 미래의 객체도 잠글 수 있다..(id > 5 and id &#x3C; 10)</p>
<h3 id="색인-범위-잠금" style="position:relative;"><a href="#%EC%83%89%EC%9D%B8-%EB%B2%94%EC%9C%84-%EC%9E%A0%EA%B8%88" aria-label="색인 범위 잠금 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>색인 범위 잠금</h3>
<p>그런데 진행중인 트랜잭션이 획득한 잠금이 많으면 잠금을 확인하는데 시간이 오래 걸린다. 그래서 2PL을 구현하는 대부분의 DB는 색인 범위 잠금(index-range locking)을 사용한다. 서술 잠금보다 더 많은 범위의 객체를 index를 이용해 잠근다. 아마 해당 column에 index가 걸려있을 것이므로... 해당 index가 없으면 전체 테이블을 잠글 수 있다.</p>
<p>다른 트랜잭션이 갱실할 때 색인도 갱신해야하므로 색인을 잠그면 팬텀을 막을 수 있다. 정밀하지는 않지만 오버헤드가 낮다.</p>
<h2 id="직렬성-스냅숏-격리ssi" style="position:relative;"><a href="#%EC%A7%81%EB%A0%AC%EC%84%B1-%EC%8A%A4%EB%83%85%EC%88%8F-%EA%B2%A9%EB%A6%ACssi" aria-label="직렬성 스냅숏 격리ssi permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>직렬성 스냅숏 격리(SSI)</h2>
<p>2008년에 처음 기술된 알고리즘. Serializable snapshot isolation, SSI</p>
<ul>
<li>2PL은 비관적 동시성 제어이다. 잘못될 가능성이 있으면 괜찮아질때까지 기다린다.</li>
<li>직렬실행은 전체 DB에 독점적인 잠금을 거는 것으로 볼 수 있으므로 극단적인 비관적 제어이다.</li>
<li>SSI는 반대로 낙관적 제어이다. 일단 해보고 충돌이 생기면 abort한다.</li>
<li>경쟁이 심하면 성능이 감소하나 예비 처리량이 충분하고 트랜잭션이 너무 경쟁하지 않으면 비관적 제어보다 성능이 좋다.</li>
<li>또한 경쟁은 commutative 원자적 연산을 이용해 줄일 수 있다. (카운터 증가)</li>
</ul>
<p>쓰기 스큐는 갱신된 전제에 기반한 결정때문에 생긴다. DB가 트랜잭션 도중에 전제가 바뀌었는지를 감지할 때 두가지 상황을 고려해야한다.</p>
<ul>
<li>오래된 MVCC(다중 버전 동시성 제어) 객체 버전을 읽었는지: 읽기 전에 커밋되지 않은 쓰기 발생</li>
<li>과거의 읽기에 영향을 미치는 쓰기 감지: 읽은 후에 쓰기 실행</li>
</ul>
<h3 id="오래된-mvcc-읽기-감지하기" style="position:relative;"><a href="#%EC%98%A4%EB%9E%98%EB%90%9C-mvcc-%EC%9D%BD%EA%B8%B0-%EA%B0%90%EC%A7%80%ED%95%98%EA%B8%B0" aria-label="오래된 mvcc 읽기 감지하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>오래된 MVCC 읽기 감지하기</h3>
<ul>
<li>트랜잭션이 커밋할 때 DB의 무시한 트랜잭션 중 커밋된 트랜잭션이 있는지 검사한다.</li>
<li>
<p>왜 오래된 읽기가 감지했을 때 abort 시키지 않고 커밋할때까지 기다릴까?</p>
<ul>
<li>트랜잭션이 읽기 전용이라면 상관 없다.</li>
<li>갱신한 트랜잭션이 abort 될 수도 있다.</li>
</ul>
</li>
</ul>
<h3 id="과거의-읽기에-영향을-미치는-쓰기-감지하기" style="position:relative;"><a href="#%EA%B3%BC%EA%B1%B0%EC%9D%98-%EC%9D%BD%EA%B8%B0%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%93%B0%EA%B8%B0-%EA%B0%90%EC%A7%80%ED%95%98%EA%B8%B0" aria-label="과거의 읽기에 영향을 미치는 쓰기 감지하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>과거의 읽기에 영향을 미치는 쓰기 감지하기</h3>
<ul>
<li>색인 범위 잠금과 비슷하지만 다른 트랜젝션을 차단하지 않는다.</li>
</ul>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 658px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/91f587fcda841b827fe1fdef6d3edad9/f0afc/fig7-11.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 70.52023121387285%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1SyxB//8QAFRABAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQEAAQUCbX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAADAAIDAAAAAAAAAAAAAAAAAREQITFRcf/aAAgBAQABPyF9nD9w9Uo6U//aAAwDAQACAAMAAAAQcA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAACAwADAAAAAAAAAAAAAAABEQAhMVFxof/aAAgBAQABPxCoBE0aUeLdlAzuwJAg9xiRIQ5joV7P/9k='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Fig.7-11"
        title="Fig.7-11"
        src="/static/91f587fcda841b827fe1fdef6d3edad9/f0afc/fig7-11.jpg"
        srcset="/static/91f587fcda841b827fe1fdef6d3edad9/9ac50/fig7-11.jpg 173w,
/static/91f587fcda841b827fe1fdef6d3edad9/8d48c/fig7-11.jpg 345w,
/static/91f587fcda841b827fe1fdef6d3edad9/f0afc/fig7-11.jpg 658w"
        sizes="(max-width: 658px) 100vw, 658px"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
        loading="lazy"
      />
  </a>
    </span></p>
<ol>
<li>읽을 때 사용한 색인을 기록한다.(트랜잭션이 끝나고 동시에 실행되는 트랜잭션이 모두 끝나면 버려도 된다.)</li>
<li>트랜젝션이 DB에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인하고 알려준다.</li>
<li>커밋할 때 2에서 알림받은 트랜잭션이 커밋되었다면 어보트한다.</li>
</ol>
<h3 id="성능-1" style="position:relative;"><a href="#%EC%84%B1%EB%8A%A5-1" aria-label="성능 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>성능</h3>
<ul>
<li>2PL과 비교했을 때 다른 트랜잭션이 잡고있는 잠금을 기다리지 않아도 되어 질의 지연시간 예측을 쉽게 만들고 변동도 적게 만든다.</li>
<li>읽기 전용 트랜잭션은 어떤 잠금도 없이 일관된 스냅숏 위에서 이뤄진다.</li>
<li>순차 진행과 비교시 단일 CPU 처리량에 제한받지 않는다.</li>
<li>SSI도 abort 비율에 영향을 받으므로 짧은 read-write 트랜잭션을 요구한다. 그래도 2PL/순차진행 보다는 느린 트랜잭션에 덜 민감하다.</li>
</ul>
<h1 id="정리" style="position:relative;"><a href="#%EC%A0%95%EB%A6%AC" aria-label="정리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정리</h1>
<h2 id="문제들" style="position:relative;"><a href="#%EB%AC%B8%EC%A0%9C%EB%93%A4" aria-label="문제들 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>문제들</h2>
<ul>
<li>더티 읽기</li>
<li>더티 쓰기</li>
<li>읽기 스큐(비반복 읽기)</li>
<li>갱신손실</li>
<li>쓰기 스큐</li>
<li>팬텀 읽기</li>
</ul></div><div></div></div></div><footer class="footer"><div class="notice-container"><a href="mailto:atobaum@gmail.com"><svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="envelope" class="svg-inline--fa fa-envelope fa-w-16 fa-2x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg></a><a href="https://github.com/atobaum"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16 fa-2x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="https://twitter.com/atobaum"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter fa-w-16 fa-2x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="/rss.xml"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" class="svg-inline--fa fa-rss fa-w-14 fa-2x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg></a></div><h4>© 2021. Atobaum. All rights reserved.</h4></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/post/데이터-중심-애플리케이션-설계-7-장-트랜잭션";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-f6a99edf9ebdd95a6344.js"],"app":["/app-5a74487c9378356be313.js"],"component---cache-caches-gatsby-plugin-offline-app-shell-js":["/component---cache-caches-gatsby-plugin-offline-app-shell-js-780d0321bb4481125aff.js"],"component---src-pages-about-jsx":["/component---src-pages-about-jsx-32cbb11d2e9461b13711.js"],"component---src-templates-category-jsx":["/component---src-templates-category-jsx-0cd81c17eb982268da84.js"],"component---src-templates-listing-jsx":["/component---src-templates-listing-jsx-27ecc5706f6b1c2e657b.js"],"component---src-templates-post-jsx":["/component---src-templates-post-jsx-2b0cecb703aadd8b79e4.js"],"component---src-templates-tag-jsx":["/component---src-templates-tag-jsx-62012a079209691f24ac.js"]};/*]]>*/</script><script src="/polyfill-f6a99edf9ebdd95a6344.js" nomodule=""></script><script src="/component---src-templates-post-jsx-2b0cecb703aadd8b79e4.js" async=""></script><script src="/e21e9ecfc099254b06ab7617f17d97212f9248d1-32bde8e5573ff9ef915e.js" async=""></script><script src="/055375637444d55e4c67d9f02f16300c0f7f7ba2-d3424c9ea53a87a3e7b3.js" async=""></script><script src="/bb7f4ffa492396e127c4cdd5a08e6cd029ef69d4-d6203d4d98718660f286.js" async=""></script><script src="/a9a7754c-57b45f76ce0a96963629.js" async=""></script><script src="/cb1608f2-f11e37f427eb4c83525d.js" async=""></script><script src="/styles-474c0340beb1ced255f1.js" async=""></script><script src="/app-5a74487c9378356be313.js" async=""></script><script src="/532a2f07-f2cdb2c94e5ef9f5c589.js" async=""></script><script src="/framework-55f7b2ba736e89fdc740.js" async=""></script><script src="/webpack-runtime-ac968ca7b4d426fc8900.js" async=""></script></body></html>